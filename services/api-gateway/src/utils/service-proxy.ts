// src/utils/service-proxy.ts
import axios, { AxiosRequestConfig } from 'axios';
import { Request, Response } from 'express';
import { appConfig } from '../config';
import { ApiError } from '../middlewares/error.middleware';
import { logger } from '../middlewares/logging.middleware';

type ServiceName = keyof typeof appConfig.serviceUrls;

/**
 * Proxy requests to microservices
 */
export const proxyToService = (service: ServiceName, path: string) => {
    return async (req: Request, res: Response): Promise<Response | void> => {
        const serviceUrl = appConfig.serviceUrls[service];
        const fullPath = path.includes(':')
            ? replacePathParams(path, req.params)
            : path;

        const url = `${serviceUrl}${fullPath}${getQueryString(req.query)}`;

        try {
            // Configure axios request
            const config: AxiosRequestConfig = {
                method: req.method,
                url,
                headers: getForwardedHeaders(req),
                timeout: appConfig.timeouts[service as keyof typeof appConfig.timeouts] || appConfig.timeouts.default
            };

            // Add request body for non-GET requests
            if (['POST', 'PUT', 'PATCH'].includes(req.method)) {
                config.data = req.body;
            }

            // Log the outgoing request in development
            if (process.env.NODE_ENV === 'development') {
                logger.debug(`Proxying to ${service} service: ${req.method} ${url}`);
            }

            // Make the request to the service
            const response = await axios(config);

            // Forward the response back to the client
            return res.status(response.status).json(response.data);
        } catch (error) {
            // Return the result of handleProxyError explicitly
            return handleProxyError(error, service, res);
        }
    };
};

/**
 * Replace path parameters in the URL
 */
const replacePathParams = (path: string, params: Record<string, any>): string => {
    let result = path;
    Object.keys(params).forEach(key => {
        result = result.replace(`:${key}`, params[key]);
    });
    return result;
};

/**
 * Build query string from request query parameters
 */
const getQueryString = (query: Record<string, any>): string => {
    if (!query || Object.keys(query).length === 0) {
        return '';
    }

    const queryParams = new URLSearchParams();

    Object.keys(query).forEach(key => {
        if (Array.isArray(query[key])) {
            query[key].forEach((value: string) => {
                queryParams.append(key, value);
            });
        } else {
            queryParams.append(key, query[key]);
        }
    });

    return `?${queryParams.toString()}`;
};

/**
 * Get headers to forward to microservice
 */
const getForwardedHeaders = (req: Request): Record<string, string> => {
    const headers: Record<string, string> = {};

    // Forward authorization header
    if (req.headers.authorization) {
        headers.authorization = req.headers.authorization;
    }

    // Forward content type
    if (req.headers['content-type']) {
        headers['content-type'] = req.headers['content-type'] as string;
    }

    // Forward accept header
    if (req.headers.accept) {
        headers.accept = req.headers.accept;
    }

    // Forward user agent
    if (req.headers['user-agent']) {
        headers['user-agent'] = req.headers['user-agent'];
    }

    // Add X-Forwarded headers
    headers['x-forwarded-for'] = req.ip || '127.0.0.1';
    headers['x-forwarded-proto'] = req.protocol;
    headers['x-forwarded-host'] = req.hostname;

    // Add request ID if generated by logging middleware
    if (req.headers['x-request-id']) {
        headers['x-request-id'] = req.headers['x-request-id'] as string;
    }

    return headers;
};

/**
 * Handle errors from proxied requests
 */
const handleProxyError = (error: any, service: string, res: Response): Response | never => {
    if (axios.isAxiosError(error)) {
        if (error.response) {
            // Service returned an error response
            return res.status(error.response.status).json(error.response.data);
        } else if (error.code === 'ECONNABORTED') {
            // Timeout error
            logger.error(`Service timeout: ${service} service request timed out`);
            throw new ApiError(`${service} service is currently unavailable. Please try again later.`, 503);
        } else if (error.code === 'ECONNREFUSED') {
            // Service is down
            logger.error(`Service unavailable: ${service} service is down`);
            throw new ApiError(`${service} service is currently unavailable. Please try again later.`, 503);
        }
    }

    // Unknown error
    logger.error(`Proxy error: ${error.message}`, { service, error });
    throw new ApiError('An unexpected error occurred', 500);
};
